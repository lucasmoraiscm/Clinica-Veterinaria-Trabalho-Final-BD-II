CREATE OR REPLACE FUNCTION CADASTRAR_TUTOR(NOME_TUTOR VARCHAR, CPF_TUTOR VARCHAR, DT_NASC_TUTOR DATE, FONE_TUTOR VARCHAR)
RETURNS VOID
AS $$
BEGIN
	INSERT INTO TUTOR (NOME, CPF, DT_NASC, FONE)
	VALUES (NOME_TUTOR, CPF_TUTOR, DT_NASC_TUTOR, FONE_TUTOR);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CADASTRAR_PET(NOME_PET VARCHAR, DT_NASC_PET DATE, ESPECIE_PET VARCHAR, PORTE_PET VARCHAR, 
CPF_TUTOR VARCHAR)
RETURNS VOID
AS $$
DECLARE
	COD_TUTOR_BUSCADO INT;
BEGIN
	COD_TUTOR_BUSCADO := (SELECT BUSCAR_COD_TUTOR(CPF_TUTOR));

	INSERT INTO PET (NOME, DT_NASC, ESPECIE, PORTE, COD_TUTOR)
	VALUES (NOME_PET, DT_NASC_PET, ESPECIE_PET, PORTE_PET, COD_TUTOR_BUSCADO);

	-- DEFINE O PLANO PET DO NOVO PET COMO SEM PLANO
	PERFORM CONTRATAR_PLANO_PET(CPF_TUTOR, NOME_PET, 'SEM PLANO');
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CADASTRAR_PLANO_PET(NOME_PLANO_PET VARCHAR, VALOR_PLANO_PET FLOAT, DESCONTO_CONS FLOAT, 
DESCONTO_VAC FLOAT)
RETURNS VOID
AS $$
BEGIN
	INSERT INTO PLANO_PET (NOME, VALOR, DESCONTO_CONSULTA, DESCONTO_VACINACAO)
	VALUES (NOME_PLANO_PET, VALOR_PLANO_PET, DESCONTO_CONS, DESCONTO_VAC);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CADASTRAR_ATENDENTE(NOME_ATEND VARCHAR, DT_NASC_ATEND DATE, SALARIO_ATEND FLOAT)
RETURNS VOID
AS $$
BEGIN
	INSERT INTO ATENDENTE (NOME, DT_NASC, SALARIO)
	VALUES (NOME_ATEND, DT_NASC_ATEND, SALARIO_ATEND);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CADASTRAR_VETERINARIO(NOME_VET VARCHAR, CRMV_VET VARCHAR, NOME_ESP VARCHAR)
RETURNS VOID
AS $$
DECLARE
	COD_ESP_BUSCADO INT;
BEGIN
	COD_ESP_BUSCADO := (SELECT BUSCAR_COD_ESP(NOME_ESP));

	INSERT INTO VETERINARIO (NOME, CRMV, COD_ESP)
	VALUES (NOME_VET, CRMV_VET, COD_ESP_BUSCADO);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CADASTRAR_ESPECIALIDADE(NOME_ESP VARCHAR, DESCR_ESP TEXT, VALOR_ESP FLOAT)
RETURNS VOID
AS $$
BEGIN
	INSERT INTO ESPECIALIDADE (NOME, DESCR, VALOR)
	VALUES (NOME_ESP, DESCR_ESP, VALOR_ESP);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CADASTRAR_FARMACO(NOME_FARM VARCHAR, DOSE_FARM VARCHAR, VALIDADE_FARM DATE, 
LOTE_FARM VARCHAR, VALOR_FARM FLOAT, QUANT_FARM INT, NOME_TIPO VARCHAR)
RETURNS VOID
AS $$
DECLARE
	COD_TIPO_BUSCADO INT;
BEGIN
	COD_TIPO_BUSCADO := (SELECT BUSCAR_COD_TIPO(NOME_TIPO));

	INSERT INTO FARMACO (NOME, DOSE, VALIDADE, LOTE, DT_ENTRADA, VALOR, QUANT, COD_TIPO)
	VALUES (NOME_FARM, DOSE_FARM, VALIDADE_FARM, LOTE_FARM, NOW(), VALOR_FARM, QUANT_FARM, COD_TIPO_BUSCADO);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION CONTRATAR_PLANO_PET(CPF_TUTOR VARCHAR, NOME_PET VARCHAR, NOME_PLANO_PET VARCHAR)
RETURNS VOID
AS $$
DECLARE
	COD_PET_BUSCADO INT;
	COD_PLANO_PET_BUSCADO INT;
BEGIN
	-- BUSCA O COD_PET
	COD_PET_BUSCADO := (SELECT BUSCAR_COD_PET(CPF_TUTOR, NOME_PET));

	-- BUSCA O COD_PLANO_PET
	COD_PLANO_PET_BUSCADO := (SELECT BUSCAR_COD_PLANO_PET(NOME_PLANO_PET));

	-- VERIFICA SE O PLANO SOLICITADO JÁ FOI CONTRATADO
	IF (SELECT PLANO_PET_JA_CONTRATADO(COD_PET_BUSCADO, COD_PLANO_PET_BUSCADO)) THEN
		RAISE EXCEPTION 'O plano já foi contratado';
	
	-- SENÃO, CASO JÁ EXISTA ALGUM PLANO CONTRATADO, DESATIVA OS PLANO ANTERIORES
	ELSIF (SELECT PLANO_PET_ATIVO(COD_PET_BUSCADO)) THEN
		UPDATE VINCULO
		SET STATUS = FALSE
		WHERE COD_PET = COD_PET_BUSCADO;
	END IF;

	-- CADASTRA O PLANO PET SOLICITADO
	INSERT INTO VINCULO (DT_CONTRATACAO, STATUS, COD_PET, COD_PLANO_PET) 
	VALUES (NOW(), TRUE, COD_PET_BUSCADO, COD_PLANO_PET_BUSCADO);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION REALIZAR_CONSULTA(CPF_TUTOR VARCHAR, NOME_PET VARCHAR, 
NOME_ATEND VARCHAR, FORMA_PAG_CONS VARCHAR, QUANT_PARC_CONS INT, 
CRMV_VET VARCHAR, DIAGNOSTICO_CONS TEXT)
RETURNS VOID
AS $$
DECLARE
	COD_VINCULO_BUSCADO INT;
	DESCONTO_BUSCADO FLOAT;
	COD_ATEND_BUSCADO INT;
	COD_VET_BUSCADO INT;
	VALOR_CONS_BUSCADO FLOAT;
	VALOR_CONS_DESCONTADO FLOAT;
	VALOR_PARCELA FLOAT;
	VENC_PARCELA DATE;
	COD_PAG_BUSCADO INT;
	CONTADOR INT;
BEGIN
	-- BUSCA O COD_VINCULO
	COD_VINCULO_BUSCADO := (SELECT BUSCAR_COD_VINCULO(CPF_TUTOR, NOME_PET));
	
	-- BUSCA O DESCONTO DA CONSULTA
	DESCONTO_BUSCADO := (SELECT BUSCAR_DESCONTO_CONSULTA(COD_VINCULO_BUSCADO));

	-- BUSCA O COD_ATEND
	COD_ATEND_BUSCADO := (SELECT BUSCAR_COD_ATEND(NOME_ATEND));

	-- BUSCA O COD_VET
	COD_VET_BUSCADO := (SELECT BUSCAR_COD_VET(CRMV_VET));

	-- VERIFICA SE A QUANTIDADE DE PARCELAS É MAIOR QUE 0
	IF QUANT_PARC_CONS <= 0 THEN
		RAISE EXCEPTION 'A quantidade de parcelas não pode ser 0 ou negativa';
	END IF;

	-- VALOR DA CONSULTA
	VALOR_CONS_BUSCADO := (SELECT BUSCAR_VALOR_CONSULTA(COD_VET_BUSCADO));

	-- VALOR TOTAL DA CONSULTA COM DESCONTO
	VALOR_CONS_DESCONTADO := (SELECT CALCULAR_VALOR_DESCONTADO(VALOR_CONS_BUSCADO, DESCONTO_BUSCADO));

	-- VALOR DA PARCELA
	VALOR_PARCELA := (SELECT CALCULAR_VALOR_PARCELA(VALOR_CONS_DESCONTADO, QUANT_PARC_CONS));

	-- CADASTRA O PAGAMENTO E BUSCA O COD_PAG
	INSERT INTO PAGAMENTO (FORMA_PAG, VALOR_TOTAL, QUANT_PARCELAS, DATA)
	VALUES (FORMA_PAG_CONS, VALOR_CONS_DESCONTADO, QUANT_PARC_CONS, NOW())
	RETURNING COD_PAG INTO COD_PAG_BUSCADO;

	-- CADASTRA AS PARCELAS
	FOR CONTADOR IN 1 .. QUANT_PARC_CONS LOOP
		-- SE O PAGAMENTO É À VISTA, VENCIMENTO É A DATA ATUAL E STATUS SERÁ TRUE (PAGA)
		IF QUANT_PARC_CONS = 1 THEN
			VENC_PARCELA := NOW();
			
			INSERT INTO PARCELA (VENC, VALOR, STATUS, COD_PAG)
			VALUES (VENC_PARCELA, VALOR_PARCELA, TRUE, COD_PAG_BUSCADO);
		
		-- SENÃO, VENCIMENTO INICIA A PARTIR DE 1 MÊS E STATUS SERÁ FALSE (NÃO PAGA)
		ELSE
			VENC_PARCELA := NOW() + CONTADOR * INTERVAL '1 month';
			
			INSERT INTO PARCELA (VENC, VALOR, STATUS, COD_PAG)
			VALUES (VENC_PARCELA, VALOR_PARCELA, FALSE, COD_PAG_BUSCADO);
		END IF;
	END LOOP;

	-- CADASTRA A CONSULTA
	INSERT INTO CONSULTA (DATA, HORA, DIAGNOSTICO, COD_VET, COD_VINCULO, COD_ATEND, COD_PAG, COD_MEDICACAO)
	VALUES (NOW(), NOW(), DIAGNOSTICO_CONS, COD_VET_BUSCADO, COD_VINCULO_BUSCADO, COD_ATEND_BUSCADO, COD_PAG_BUSCADO, NULL);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION REALIZAR_CONSULTA(CPF_TUTOR VARCHAR, NOME_PET VARCHAR, 
NOME_ATEND VARCHAR, FORMA_PAG_CONS VARCHAR, QUANT_PARC_CONS INT, 
CRMV_VET VARCHAR, DIAGNOSTICO_CONS TEXT, NOME_FARMACO VARCHAR)
RETURNS VOID
AS $$
DECLARE
	COD_VINCULO_BUSCADO INT;
	DESCONTO_BUSCADO FLOAT;
	COD_ATEND_BUSCADO INT;
	COD_VET_BUSCADO INT;
	VALOR_CONS_BUSCADO FLOAT;
	COD_FARM_BUSCADO INT;
	VALOR_FARM_BUSCADO FLOAT;
	COD_MEDICACAO_BUSCADO INT;
	VALOR_CONS_DESCONTADO FLOAT;
	VALOR_TOTAL_CONS FLOAT;
	VALOR_PARCELA FLOAT;
	VENC_PARCELA DATE;
	COD_PAG_BUSCADO INT;
	CONTADOR INT;
BEGIN
	-- BUSCA O COD_VINCULO
	COD_VINCULO_BUSCADO := (SELECT BUSCAR_COD_VINCULO(CPF_TUTOR, NOME_PET));
	
	-- BUSCA O DESCONTO DA CONSULTA
	DESCONTO_BUSCADO := (SELECT BUSCAR_DESCONTO_CONSULTA(COD_VINCULO_BUSCADO));

	-- BUSCA O COD_ATEND
	COD_ATEND_BUSCADO := (SELECT BUSCAR_COD_ATEND(NOME_ATEND));

	-- BUSCA O COD_VET
	COD_VET_BUSCADO := (SELECT BUSCAR_COD_VET(CRMV_VET));

	-- VERIFICA SE A QUANTIDADE DE PARCELAS É MAIOR QUE 0
	IF QUANT_PARC_CONS <= 0 THEN
		RAISE EXCEPTION 'A quantidade de parcelas não pode ser 0 ou negativa';
	END IF;

	-- VALOR DA CONSULTA
	VALOR_CONS_BUSCADO := (SELECT BUSCAR_VALOR_CONSULTA(COD_VET_BUSCADO));

	-- BUSCA O COD_FARM
	COD_FARM_BUSCADO := (SELECT BUSCAR_COD_FARM(NOME_FARMACO));

	-- BUSCA O VALOR DO FÁRMACO
	VALOR_FARM_BUSCADO := (SELECT BUSCAR_VALOR_FARMACO(COD_FARM_BUSCADO));

	-- CADASTRA A MEDICAÇÃO E BUSCA O COD_MEDICACAO
	INSERT INTO MEDICACAO (DATA, HORA, COD_FARM)
	VALUES (NOW(), NOW(), COD_FARM_BUSCADO)
	RETURNING COD_MEDICACAO INTO COD_MEDICACAO_BUSCADO;

	-- VALOR TOTAL DA CONSULTA COM DESCONTO
	VALOR_CONS_DESCONTADO := (SELECT CALCULAR_VALOR_DESCONTADO(VALOR_CONS_BUSCADO, DESCONTO_BUSCADO));

	-- VALOR TOTAL DA CONSULTA + MEDICACAO
	VALOR_TOTAL_CONS := VALOR_CONS_DESCONTADO + VALOR_FARM_BUSCADO;

	-- VALOR DA PARCELA
	VALOR_PARCELA := (SELECT CALCULAR_VALOR_PARCELA(VALOR_TOTAL_CONS, QUANT_PARC_CONS));

	-- CADASTRA O PAGAMENTO E BUSCA O COD_PAG
	INSERT INTO PAGAMENTO (FORMA_PAG, VALOR_TOTAL, QUANT_PARCELAS, DATA)
	VALUES (FORMA_PAG_CONS, VALOR_TOTAL_CONS, QUANT_PARC_CONS, NOW())
	RETURNING COD_PAG INTO COD_PAG_BUSCADO;

	-- CADASTRA AS PARCELAS
	FOR CONTADOR IN 1 .. QUANT_PARC_CONS LOOP
		-- SE O PAGAMENTO É À VISTA, VENCIMENTO É A DATA ATUAL E STATUS SERÁ TRUE (PAGA)
		IF QUANT_PARC_CONS = 1 THEN
			VENC_PARCELA := NOW();
			
			INSERT INTO PARCELA (VENC, VALOR, STATUS, COD_PAG)
			VALUES (VENC_PARCELA, VALOR_PARCELA, TRUE, COD_PAG_BUSCADO);
		
		-- SENÃO, VENCIMENTO INICIA A PARTIR DE 1 MÊS E STATUS SERÁ FALSE (NÃO PAGA)
		ELSE
			VENC_PARCELA := NOW() + CONTADOR * INTERVAL '1 month';
			
			INSERT INTO PARCELA (VENC, VALOR, STATUS, COD_PAG)
			VALUES (VENC_PARCELA, VALOR_PARCELA, FALSE, COD_PAG_BUSCADO);
		END IF;
	END LOOP;

	-- CADASTRA A CONSULTA
	INSERT INTO CONSULTA (DATA, HORA, DIAGNOSTICO, COD_VET, COD_VINCULO, COD_ATEND, COD_PAG, COD_MEDICACAO)
	VALUES (NOW(), NOW(), DIAGNOSTICO_CONS, COD_VET_BUSCADO, COD_VINCULO_BUSCADO, COD_ATEND_BUSCADO, COD_PAG_BUSCADO, 
	COD_MEDICACAO_BUSCADO);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION REALIZAR_VACINACAO(CPF_TUTOR VARCHAR, NOME_PET VARCHAR, 
NOME_ATEND VARCHAR, FORMA_PAG_VAC VARCHAR, QUANT_PARC_VAC INT, CRMV_VET VARCHAR, 
NOME_FARMACO VARCHAR)
RETURNS VOID
AS $$
DECLARE
	COD_VINCULO_BUSCADO INT;
	DESCONTO_BUSCADO FLOAT;
	COD_ATEND_BUSCADO INT;
	COD_VET_BUSCADO INT;
	COD_FARM_BUSCADO INT;
	VALOR_FARM_BUSCADO FLOAT;
	VALOR_VAC_DESCONTADO FLOAT;
	VALOR_PARCELA FLOAT;
	VENC_PARCELA DATE;
	COD_PAG_BUSCADO INT;
	CONTADOR INT;
BEGIN
	-- BUSCA O COD_VINCULO
	COD_VINCULO_BUSCADO := (SELECT BUSCAR_COD_VINCULO(CPF_TUTOR, NOME_PET));

	-- BUSCA O DESCONTO DA VACINACAO
	DESCONTO_BUSCADO := (SELECT BUSCAR_DESCONTO_VACINACAO(COD_VINCULO_BUSCADO));

	-- BUSCA O COD_ATEND
	COD_ATEND_BUSCADO := (SELECT BUSCAR_COD_ATEND(NOME_ATEND));

	-- BUSCA O COD_VET
	COD_VET_BUSCADO := (SELECT BUSCAR_COD_VET(CRMV_VET));

	-- BUSCA O COD_FARM
	COD_FARM_BUSCADO := (SELECT BUSCAR_COD_FARM(NOME_FARMACO));

	-- BUSCA O VALOR DO FÁRMACO
	VALOR_FARM_BUSCADO := (SELECT BUSCAR_VALOR_FARMACO(COD_FARM_BUSCADO));

	-- VERIFICA SE A QUANTIDADE DE PARCELAS É MAIOR QUE 0
	IF QUANT_PARC_VAC <= 0 THEN
		RAISE EXCEPTION 'A quantidade de parcelas não pode ser 0 ou negativa';
	END IF;

	-- VALOR TOTAL DA VACINAÇÃO COM DESCONTO
	VALOR_VAC_DESCONTADO := (SELECT CALCULAR_VALOR_DESCONTADO(VALOR_FARM_BUSCADO, DESCONTO_BUSCADO));

	-- VALOR DA PARCELA
	VALOR_PARCELA := (SELECT CALCULAR_VALOR_PARCELA(VALOR_VAC_DESCONTADO, QUANT_PARC_VAC));

	-- CADASTRA O PAGAMENTO E BUSCA O COD_PAG
	INSERT INTO PAGAMENTO (FORMA_PAG, VALOR_TOTAL, QUANT_PARCELAS, DATA)
	VALUES (FORMA_PAG_VAC, VALOR_VAC_DESCONTADO, QUANT_PARC_VAC, NOW())
	RETURNING COD_PAG INTO COD_PAG_BUSCADO;

	-- CADASTRA AS PARCELAS
	FOR CONTADOR IN 1 .. QUANT_PARC_VAC LOOP
		-- SE O PAGAMENTO É À VISTA, VENCIMENTO É A DATA ATUAL E STATUS SERÁ TRUE (PAGA)
		IF QUANT_PARC_VAC = 1 THEN
			VENC_PARCELA := NOW();
			
			INSERT INTO PARCELA (VENC, VALOR, STATUS, COD_PAG)
			VALUES (VENC_PARCELA, VALOR_PARCELA, TRUE, COD_PAG_BUSCADO);
		
		-- SENÃO, VENCIMENTO INICIA A PARTIR DE 1 MÊS E STATUS SERÁ FALSE (NÃO PAGA)
		ELSE
			VENC_PARCELA := NOW() + CONTADOR * INTERVAL '1 month';
			
			INSERT INTO PARCELA (VENC, VALOR, STATUS, COD_PAG)
			VALUES (VENC_PARCELA, VALOR_PARCELA, FALSE, COD_PAG_BUSCADO);
		END IF;
	END LOOP;

	-- CADASTRA A VACINACAO
	INSERT INTO VACINACAO (DATA, HORA, COD_VET, COD_VINCULO, COD_ATEND, COD_PAG, COD_FARM) 
	VALUES (NOW(), NOW(), COD_VET_BUSCADO, COD_VINCULO_BUSCADO, COD_ATEND_BUSCADO, COD_PAG_BUSCADO, COD_FARM_BUSCADO);
END;
$$ LANGUAGE PLPGSQL;



CREATE OR REPLACE FUNCTION REABASTECER_ESTOQUE(NOME_FARMACO VARCHAR, QUANT_FARMACO INT)
RETURNS VOID
AS $$
DECLARE
	COD_FARM_BUSCADO INT;
BEGIN
	COD_FARM_BUSCADO := BUSCAR_COD_FARM(NOME_FARMACO);

	-- SE A QUANTIDADE FOR MAIOR QUE 0, ABASTECE O ESTOQUE DO FARMACO
	IF QUANT_FARMACO > 0 THEN
		UPDATE FARMACO
		SET QUANT = QUANT + QUANT_FARMACO
		WHERE COD_FARM = COD_FARM_BUSCADO;
	ELSE
		RAISE EXCEPTION 'A quantidade do fármaco a ser reabastecido deve ser maior que 0';
	END IF;
END;
$$ LANGUAGE PLPGSQL;


